--  Primeira função

CREATE FUNCTION PRIMEIRA_FUNCAO() RETURNS INTEGER AS '
	SELECT (5 - 3) * 2;
' LANGUAGE SQL;

-- BUSCANDO A FUNCAO
SELECT PRIMEIRA_FUNCAO();

-- RENOMEAR SELECT
SELECT PRIMEIRA_FUNCAO() AS NUMERO;

-- Recebendo parâmetros

-> 'Informando o valor dentro dos paranteses, o campo fica restrito, como por exemplo integer, que só ira aceitar valores inteiros'
CREATE FUNCTION SOMADOIS(NUMERO_1 INTEGER, NUMERO_2 INTEGER) RETURNS INTEGER AS ' 
	SELECT NUMERO_1 + NUMERO_2;	
' LANGUAGE SQL;

--INFORMAR OS VALORES DA FUNÇÃO, PARA EXECUTA-LÁ.
SELECT SOMADOIS(2,5)

-- SE NÃO DEFINIMOS OS CAMPOS DENTRO DO PARANTESES, PODEMOS DEFINIR DENTRO DA FUNÇÃO OS CAMPOS
CREATE FUNCTION SOMADOIS(INTEGER, INTEGER) RETURNS INTEGER AS ' 
	SELECT $1 + $2;	
' LANGUAGE SQL;

--EXCLUIR FUNCTION
DROP FUNCTION SOMADOIS;

--Detalhes sobre funções
-- DEMONSTRANDO UM ERRO DENTRO DA FUNCTION

CREATE TABLE A(NOME VARCHAR(255) NOT NULL);
CREATE FUNCTION CRIA_A(NOME VARCHAR) RETURNS VARCHAR AS '
	INSERT INTO A(NOME) VALUES (CRIA_A.NOME);
	SELECT NOME;
' LANGUAGE SQL;

-- O ÚLTIMO VALOR DA FUNÇÃO, PRECISAR RETORNAR ALGUM VALOR.

-- QUANDO TESTAR FUNÇÕES, NÃO É NECESSÁRIO REALIZAR O DROP, APENSAR USAR O COMANDO REPLACE

CREATE OR REPLACE FUNCTION CRIA_A(NOME VARCHAR) RETURNS VARCHAR AS '
	INSERT INTO A(NOME) VALUES (CRIA_A.NOME);
	SELECT NOME;
' LANGUAGE SQL;

SELECT CRIA_A('LUCAS SILVA');

-- SE QUISER APENSAR INSERIR O VALOR, SEM RETORNAR, BASTA ALTERAR DEPOIS DO RETURNS E COLOCAR "VOID";

--INSERIR VALOR, DIRETO DO INSERT, DENTRO DA FUNCTION
--PODEMOS TROCAR AS ASPAS, POR A NOTAÇÃO DE DÓLAR
CREATE OR REPLACE FUNCTION CRIA_A(NOME VARCHAR) RETURNS VARCHAR AS $$
	INSERT INTO A(NOME) VALUES ('PATRICIA');
	SELECT NOME;
$$ LANGUAGE SQL;


-- Parâmetros compostos

CREATE TABLE INSTRUTOR(
	ID SERIAL PRIMARY KEY,
	NOME VARCHAR(255) NOT NULL,
	SALARIO DECIMAL(10,2)
);

INSERT INTO INSTRUTOR (NOME, SALARIO) VALUES ('Lucas Silva', 5000);

-- O CAMPO INSTRUTOR DENTRO DO PARENTESES, É A TABELA COMO PARAMETRO, COM ISSO, DENTRO DO SELECT CONSEGUIMOS ACESSAR O CAMPO SALARIO DA MESMA
CREATE FUNCTION DOBRO_SALARIO (INSTRUTOR) RETURNS DECIMAL AS $$
	SELECT $1.salario * 2 as dobro;	
$$ LANGUAGE SQL;


SELECT NOME, DOBRO_SALARIO(INSTRUTOR.*) FROM INSTRUTOR;

-- Retorno composto

-- NESSE CASO, CRIAMOS UMA FUNÇÃO QUE DEVOLVE UM ITEM DE UMA TABELA, MAS OS TIPOS PRECISAM EXISTIR.
CREATE FUNCTION CRIA_INSTUTOR_FALSO() RETURNS INSTRUTOR AS $$ 
	SELECT 22, 'NOME FALSO', 222::DECIMAL;
$$ LANGUAGE SQL;


SELECT CRIA_INSTUTOR_FALSO();
SELECT * FROM CRIA_INSTUTOR_FALSO();


-- Retornando conjuntos
INSERT INTO INSTRUTOR (NOME, SALARIO) VALUES ('INSTRUTOR2', 2000);
INSERT INTO INSTRUTOR (NOME, SALARIO) VALUES ('INSTRUTOR3', 4000);
INSERT INTO INSTRUTOR (NOME, SALARIO) VALUES ('INSTRUTOR4', 1500);
INSERT INTO INSTRUTOR (NOME, SALARIO) VALUES ('INSTRUTOR5', 10000);
INSERT INTO INSTRUTOR (NOME, SALARIO) VALUES ('INSTRUTOR6', 3800);
INSERT INTO INSTRUTOR (NOME, SALARIO) VALUES ('INSTRUTOR7', 2800);

-- O SETOF, SERVE PARA TRAZERMOS UM CONJUTO DE VALORES
CREATE FUNCTION INSTRUTOR_BEM_PAGO (VALOR_SALARIO DECIMAL)RETURNS  SETOF  INSTRUTOR  AS $$ 
	SELECT * FROM INSTRUTOR WHERE SALARIO > VALOR_SALARIO;
$$ LANGUAGE SQL;


SELECT * FROM  INSTRUTOR_BEM_PAGO(2000);

-- Parâmetros de saída

CREATE FUNCTION SOMA_E_PRODUTO (NUMERO_1 INTEGER, NUMERO_2 INTEGER, OUT SOMA INTEGER, OUT PRODUTO INTEGER) AS $$ 
	SELECT NUMERO_2 + NUMERO_2 AS SOMA, NUMERO_1 * NUMERO_2 AS PRODUTO;
$$ LANGUAGE SQL; 


SELECT * FROM SOMA_E_PRODUTO(3,3);

DROP FUNCTION INSTRUTOR_BEM_PAGO
CREATE FUNCTION INSTRUTOR_BEM_PAGO (VALOR_SALARIO DECIMAL, OUT NOME VARCHAR, OUT SALARIO INTEGER)RETURNS SETOF RECORD AS $$ 
	SELECT NOME, SALARIO FROM INSTRUTOR WHERE SALARIO > VALOR_SALARIO;
$$ LANGUAGE SQL;


-- PostgreSQL e PLs
 -- Estrutura de PLpgSQL
 -- UTILIZANDO O PLPGSQL, PRECISAMOS DEFINIR UM BLOCO DE CÓDIGOS.
 CREATE OR REPLACE FUNCTION PRIMEIRA_PL() RETURNS INTEGER AS $$ 
 	BEGIN
	-- PODEMOS TER VÁRIOS COMANDO SQL
	RETURN 1;
	-- MAS PRECISAMOS DE UM RETURN
	END	
 $$ LANGUAGE PLPGSQL;
 
  SELECT FROM PRIMEIRA_PL();
 
 
 --Declarações de variáveis
 -- Declarar a variável antes do begin
 -- PODEMOS TER VÁRIOS COMANDO SQL
 -- MAS PRECISAMOS DE UM RETURN
  CREATE OR REPLACE FUNCTION PRIMEIRA_PL() RETURNS INTEGER AS $$ 
 	DECLARE
		PRIMEIRA_VARIAVEL INTEGER DEFAULT 3;
	BEGIN
	PRIMEIRA_VARIAVEL := PRIMEIRA_VARIAVEL  * 2;
	RETURN PRIMEIRA_VARIAVEL;
	END	
 $$ LANGUAGE PLPGSQL;
 
 SELECT PRIMEIRA_PL();
-- QUANDO DEFINIMOS O NO DECLARE, E É UM VALOR FIXO, PODEMOS USAR O DEFAUTL, NO CORPO, UTILIZAMOS O :=, COMO BOA PRÁTICA.

-- Blocos
 
 CREATE OR REPLACE FUNCTION PRIMEIRA_PL() RETURNS INTEGER AS $$ 
 	DECLARE
		PRIMEIRA_VARIAVEL INTEGER DEFAULT 3;
	BEGIN
	PRIMEIRA_VARIAVEL := PRIMEIRA_VARIAVEL  * 2;
		BEGIN PRIMEIRA_VARIAVEL := 7;
		END;
	RETURN PRIMEIRA_VARIAVEL;
	END	
 $$ LANGUAGE PLPGSQL;
 
 SELECT PRIMEIRA_PL();
 
 
 -- Retornos em PLs
 
CREATE OR REPLACE FUNCTION CRIA_INSTRUTOR_FALSO() RETURNS INSTRUTOR AS $$ 
	BEGIN
	RETURN ROW (22, 'NOME FALSO', 200::DECIMAL)::INSTRUTOR;
	END;
$$ LANGUAGE PLPGSQL;

-- OUTRO MODO DE RETORNO


CREATE OR REPLACE FUNCTION CRIA_INSTRUTOR_FALSO() RETURNS INSTRUTOR AS $$ 
	DECLARE RETORNO INSTRUTOR;
	BEGIN
	SELECT 22, 'NOME FALSO', 200::DECIMAL INTO RETORNO;
	RETURN RETORNO;
	END;
$$ LANGUAGE PLPGSQL;

DROP FUNCTION INSTRUTOR_BEM_PAGO;
CREATE FUNCTION INSTRUTOR_BEM_PAGO (VALOR_SALARIO DECIMAL) RETURNS SETOF INSTRUTOR AS $$ 
	BEGIN
	RETURN QUERY SELECT * FROM INSTRUTOR WHERE SALARIO > VALOR_SALARIO;
	END;
$$ LANGUAGE PLPGSQL;

SELECT * FROM  INSTRUTOR_BEM_PAGO(500);

-- If - Else

CREATE FUNCTION SALARIO_OK(INSTRUTOR INSTRUTOR) RETURNS VARCHAR AS $$ 
	BEGIN
		IF INSTRUTOR.SALARIO > 4000 THEN
			RETURN 'SALARIO OK';
		ELSE 
			RETURN 'SALARIO PODE AUMENTAR';
			END IF;
	END;
$$ LANGUAGE PLPGSQL;

SELECT NOME, SALARIO_OK(INSTRUTOR) FROM INSTRUTOR;


-- ElseIf
	
CREATE OR REPLACE FUNCTION SALARIO_OK(INSTRUTOR INSTRUTOR) RETURNS VARCHAR AS $$ 
	BEGIN
		IF INSTRUTOR.SALARIO > 4000 THEN
			RETURN 'SALARIO OK';
			ELSEIF INSTRUTOR.SALARIO = 4000 THEN
				RETURN 'SALARIO PODE AUEMNTAR';
				ELSE
				RETURN 'SALARIO DEFASADO';
		END IF;
	END;
$$ LANGUAGE PLPGSQL;

SELECT NOME, SALARIO_OK(INSTRUTOR) FROM INSTRUTOR;




-- Case When

CREATE OR REPLACE FUNCTION SALARIO_OK(INSTRUTOR INSTRUTOR) RETURNS VARCHAR AS $$ 
	BEGIN
		CASE 
			WHEN INSTRUTOR.SALARIO = 2000 THEN
				RETURN 'SALARIO BAIXO';
			WHEN INSTRUTOR.SALARIO = 4000 THEN
				RETURN 'SALARIO OK';
			ELSE
				RETURN 'SALARIO ÓTIMO';
		END CASE;
	END;
$$ LANGUAGE PLPGSQL;

SELECT NOME, SALARIO_OK(INSTRUTOR) FROM INSTRUTOR;

 -- OUTRO MODO 
 
 
CREATE OR REPLACE FUNCTION SALARIO_OK(INSTRUTOR INSTRUTOR) RETURNS VARCHAR AS $$ 
	BEGIN
		CASE INSTRUTOR.SALARIO
			WHEN  2000 THEN
				RETURN 'SALARIO BAIXO';
			WHEN  4000 THEN
				RETURN 'SALARIO OK';
			ELSE
				RETURN 'SALARIO ÓTIMO';
		END CASE;
	END;
$$ LANGUAGE PLPGSQL;

SELECT NOME, SALARIO_OK(INSTRUTOR) FROM INSTRUTOR;



-- Return Next

CREATE FUNCTION TABUADA (NUMERO INTEGER) RETURNS SETOF VARCHAR AS $$ 
	DECLARE 
	BEGIN
		RETURN NEXT NUMERO * 1;
		RETURN NEXT NUMERO * 2;
		RETURN NEXT NUMERO * 3;
		RETURN NEXT NUMERO * 4;
		RETURN NEXT NUMERO * 5;
		RETURN NEXT NUMERO * 6;
		RETURN NEXT NUMERO * 7;
		RETURN NEXT NUMERO * 8;
	END;
$$ LANGUAGE PLPGSQL;


SELECT TABUADA(9);

-- Conhecendo Loop
CREATE OR REPLACE FUNCTION TABUADA (NUMERO INTEGER) RETURNS SETOF VARCHAR AS $$ 
	DECLARE
	MULTIPLICADOR INTEGER DEFAULT 1;
	BEGIN
		LOOP -- INICIANDO UM LOOPING
			RETURN NEXT NUMERO || ' X ' || MULTIPLICADOR || ' = ' || NUMERO * MULTIPLICADOR ; -- RETURN NEXT, TRÁS UM CONJUNTO DE VALORES, AO INVÉS DE UM VALOR SÓ
			MULTIPLICADOR := MULTIPLICADOR + 1; -- PEGA O NÚMERO QUE SERÁ O MULTIPLICADOR E SOMA MAIS UM, PARA A PRÓXIMA MULTI
			
			EXIT WHEN MULTIPLICADOR = 10; -- JEITO DE ACABAR O LOOPING 
		END LOOP; -- SAINDO DO LOOPING
	END;
$$ LANGUAGE PLPGSQL;

SELECT TABUADA(9);


-- WHILE
-- INICIANDO UM LOOPING, NESSE CASO, JÁ DEFINIMOS ATÉ QUANDO IRÁ O LOOPING, USANDO O WHILE, ENTÃO NÃO PRECISAMOS DO END LOOP
CREATE OR REPLACE FUNCTION TABUADA (NUMERO INTEGER) RETURNS SETOF VARCHAR AS $$ 
	DECLARE
	MULTIPLICADOR INTEGER DEFAULT 1;
	BEGIN
		WHILE MULTIPLICADOR < 10 LOOP 
			RETURN NEXT NUMERO || ' X ' || MULTIPLICADOR || ' = ' || NUMERO * MULTIPLICADOR ; -- RETURN NEXT, TRÁS UM CONJUNTO DE VALORES, AO INVÉS DE UM VALOR SÓ
			MULTIPLICADOR := MULTIPLICADOR + 1; -- PEGA O NÚMERO QUE SERÁ O MULTIPLICADOR E SOMA MAIS UM, PARA A PRÓXIMA MULTI
			
		END LOOP; -- SAINDO DO LOOPING
	END;
$$ LANGUAGE PLPGSQL;


-- Conhecendo For
-- NO FOR, NEM PRECISAMOS USAR O DECLARE, JÁ DEFINIMOS O VALOR DENTRO DELE. 
CREATE OR REPLACE FUNCTION TABUADA (NUMERO INTEGER) RETURNS SETOF VARCHAR AS $$ 
	BEGIN
		FOR MULTIPLICADOR IN 0..10 LOOP 
		RETURN NEXT NUMERO || ' X ' || MULTIPLICADOR || ' = ' || NUMERO * MULTIPLICADOR ; -- RETURN NEXT, TRÁS UM CONJUNTO DE VALORES, AO INVÉS DE UM VALOR SÓ
			
		END LOOP; -- SAINDO DO LOOPING
	END;
$$ LANGUAGE PLPGSQL;


SELECT TABUADA(10);



-- LOOPING FOR EM UMA QUERY

-- COMO É UM SELECT, TEMOS QUE DECLARAR UMA VARIÁVEL
CREATE OR REPLACE FUNCTION INSTRUTOR_SALARIO(OUT NOME VARCHAR, OUT SALARIO_OK VARCHAR) RETURNS SETOF RECORD AS $$
DECLARE
	INSTRUTOR INSTRUTOR;
	BEGIN
		FOR INSTRUTOR IN SELECT * FROM INSTRUTOR LOOP 
			NOME := INSTRUTOR.NOME; 
			SALARIO_OK = SALARIO_OK(INSTRUTOR.ID);
			
			RETURN NEXT;
		END LOOP;
	END;
$$ LANGUAGE PLPGSQL; 



-- Curso na categoria

CREATE OR REPLACE FUNCTION CRIA_CURSO(NOME_CURSO VARCHAR, NOME_CATEGORIA VARCHAR) RETURNS VOID AS $$ 
	DECLARE
		ID_CATEGORIA INTEGER;
	BEGIN
		SELECT ID INTO ID_CATEGORIA FROM CATEGORIA WHERE NOME = NOME_CATEGORIA;
		IF NOT FOUND THEN
			INSERT INTO ACADEMICO.CATEGORIA (NOME) VALUES (ACADEMICO.NOME_CATEGORIA) RETURNING ID INTO ID_CATEGORIA;
		END IF;
		
		INSERT INTO ACADEMICO.CURSO (NOME, CATEGORIA_ID) VALUES (NOME_CURSO, ID_CATEGORIA);
	END;
$$ LANGUAGE PLPGSQL;


SELECT CRIA_CURSO('PHP', 'PROGRAMAÇÃO');

SELECT * FROM CURSOS;

-- Instrutores e salários

CREATE TABLE LOG_INSTRUTORES(
	ID SERIAL PRIMARY KEY,
	INFORMACAO VARCHAR(255) NOT NULL,
	MOMENTO_CRIACAO TIMESTAMP DEFAULT CURRENT_TIMESTAMP -- CURRENT_TIMESTAMP TRÁS A HORA ATUAL
);


CREATE OR REPLACE FUNCTION CRIA_INSTUTOR(NOME VARCHAR, SALARIO_INSTRUTOR DECIMAL) RETURNS VOID AS $$
	DECLARE
	ID_INSTRUTOR_INSERIDO INTEGER;
	MEDIA DECIMAL;
	INSTRUTOR_MENOS INTEGER DEFAULT 0;
	TOTAL_INSTRUTOR INTEGER DEFAULT 0;
	SALARIO DECIMAL;
	PERCENTUAL DECIMAL; 
	BEGIN
		INSERT INTO INSTRUTOR(NOME, SALARIO) VALUES (NOME, SALARIO_INSTRUTOR) RETURNING ID INTO ID_INSTRUTOR_INSERIDO;
		
		SELECT AVG(INSTRUTOR.SALARIO) INTO MEDIA FROM INSTRUTOR WHERE ID <> ID_INSTRUTOR_INSERIDO;
		IF SALARIO_INSTRUTOR > MEDIA THEN
			INSERT INTO LOG_INSTRUTORES(INFORMACAO) VALUES (NOME || 'RECEBE ACIMA DA MÉDIA');
		END IF;
		
		FOR SALARIO IN SELECT INSTRUTOR.SALARIO FROM INSTRUTOR WHERE ID <> ID_INSTRUTOR_INSERIDO LOOP
			TOTAL_INSTRUTOR := TOTAL_INSTRUTOR + 1;
			
			IF SALARIO_INSTRUTOR > SALARIO THEN
				INSTRUTOR_MENOS := INSTRUTOR_MENOS + 1;
			END IF;
		END LOOP;
		
		PERCENTUAL = INSTRUTOR_MENOS::DECIMAL / TOTAL_INSTRUTOR::DECIMAL * 100;
		
		INSERT INTO LOG_INSTRUTORES(INFORMACAO) VALUES (NOME_INSTRUTOR || 'RECEBE MAIS DO QUE ' || PERCENTUAL || '% DA GRADE DE INSTRUTORES');
	END;
$$ LANGUAGE PLPGSQL;


SELECT CRIA_INSTUTOR('FULANO', 15000);


SELECT * FROM INSTRUTOR;